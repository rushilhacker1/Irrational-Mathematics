'use strict';

var fs   = require('fs');
var path = require('path');
var zlib = require('zlib');

var GIT_DIR = '.git';

function changeGitDir(newDirName) {
  GIT_DIR = newDirName;
}

function findRepoHandleLinkedWorktree(gitPath) {
  var stat = fs.statSync(gitPath);
  var root = path.dirname(path.resolve(gitPath));
  if (stat.isDirectory()) {
    return {
      // for the base (non-linked) dir, there is no distinction between where we
      // find the HEAD file and where we find the rest of .git
      worktreeGitDir: gitPath,
      commonGitDir: gitPath,
      root: root,
    };
  } else {
    // We have a file that tells us where to find the worktree git dir.  Once we
    // look there we'll know how to find the common git dir, depending on
    // whether it's a linked worktree git dir, or a submodule dir

    var linkedGitDir = fs.readFileSync(gitPath).toString();
    var absolutePath=path.resolve(path.dirname(gitPath));
    var worktreeGitDirUnresolved = /gitdir: (.*)/.exec(linkedGitDir)[1];
    var worktreeGitDir = path.resolve(absolutePath,worktreeGitDirUnresolved);
    var commonDirPath = path.join(worktreeGitDir, 'commondir');
    if (fs.existsSync(commonDirPath)) {
      // this directory contains a `commondir` file; we're in a linked worktree

      var commonDirRelative = fs.readFileSync(commonDirPath).toString().replace(/\r?\n$/, '');
      var commonDir = path.resolve(path.join(worktreeGitDir, commonDirRelative));

      return {
        worktreeGitDir: worktreeGitDir,
        commonGitDir: commonDir,
        root: path.dirname(commonDir),
      };
    } else {
      // there is no `commondir` file; we're in a submodule
      return {
        worktreeGitDir: worktreeGitDir,
        commonGitDir: worktreeGitDir,
        root: root,
      };
    }
  }
}

function findRepo(startingPath) {
  var gitPath, lastPath;
  var currentPath = startingPath;

  if (!currentPath) { currentPath = process.cwd(); }

  do {
    gitPath = path.join(currentPath, GIT_DIR);

    if (fs.existsSync(gitPath)) {
      return findRepoHandleLinkedWorktree(gitPath);
    }

    lastPath = currentPath;
    currentPath = path.resolve(currentPath, '..');
  } while (lastPath !== currentPath);

  return null;
}

function findPackedTags(gitPath, refPath) {
  return getPackedRefsForType(gitPath, refPath, 'tag');
}

function findPackedCommit(gitPath, refPath) {
  return getPackedRefsForType(gitPath, refPath, 'commit')[0];
}

function getPackedRefsForType(gitPath, refPath, type) {
  var packedRefsFile = getPackedRefsFile(gitPath);
  if (packedRefsFile) {
    return getLinesForRefPath(packedRefsFile, type, refPath).map(function(shaLine) {
      return getShaBasedOnType(type, shaLine);
    });
  }
  return [];
}

function getPackedRefsFile(gitPath) {
  var packedRefsFilePath = path.join(gitPath, 'packed-refs');
  return fs.existsSync(packedRefsFilePath) ? fs.readFileSync(packedRefsFilePath, { encoding: 'utf8' }) : false;
}

function getLinesForRefPath(packedRefsFile, type, refPath) {
  return packedRefsFile.split(/\r?\n/).reduce(function(acc, line, idx, arr) {
    var targetLine = line.indexOf('^') > -1 ? arr[idx-1] : line;
    return doesLineMatchRefPath(type, line, refPath) ? acc.concat(targetLine) : acc;
  }, []);
}

function doesLineMatchRefPath(type, line, refPath) {
  var refPrefix = type === 'tag' ? 'refs/tags' : 'refs/heads';
  return (line.indexOf(refPrefix) > -1 || line.indexOf('^') > -1) && line.indexOf(refPath) > -1;
}

function getShaBasedOnType(type, shaLine) {
  var shaResult = '';
  if (type === 'tag') {
    shaResult = shaLine.split('tags/')[1];
  } else if (type === 'commit') {
    shaResult = shaLine.split(' ')[0];
  }

  return shaResult;
}

function commitForTag(gitPath, tag) {
  var tagPath = path.join(gitPath, 'refs', 'tags', tag);
  var tag